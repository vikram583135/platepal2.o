[
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "653d7c58-e824-4dcd-90c9-6311ff7e1008",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC001-login with email and password",
    "description": "Test the /api/auth/token/ endpoint to verify successful login using valid email and password credentials, and ensure that access and refresh tokens are returned correctly.",
    "code": "import requests\n\ndef test_login_with_email_and_password():\n    base_url = \"http://localhost:3020\"\n    login_endpoint = f\"{base_url}/api/auth/token/\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Provide valid test credentials for login\n    payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n\n    try:\n        response = requests.post(login_endpoint, json=payload, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n\n    # Validate response content for access and refresh tokens\n    json_response = response.json()\n    assert \"access\" in json_response, \"Response JSON does not contain 'access' token\"\n    assert \"refresh\" in json_response, \"Response JSON does not contain 'refresh' token\"\n    assert isinstance(json_response[\"access\"], str) and len(json_response[\"access\"]) > 0, \"'access' token is empty or invalid\"\n    assert isinstance(json_response[\"refresh\"], str) and len(json_response[\"refresh\"]) > 0, \"'refresh' token is empty or invalid\"\n\ntest_login_with_email_and_password()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 17, in test_login_with_email_and_password\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 32, in <module>\n  File \"<string>\", line 20, in test_login_with_email_and_password\nAssertionError: HTTP request failed: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.602Z",
    "modified": "2025-11-17T16:25:11.788Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "09da2971-0815-4b9d-8132-0478c57d84c4",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC002-refresh access token",
    "description": "Test the /api/auth/token/refresh/ endpoint to verify that a valid refresh token can be used to obtain a new access token successfully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3020\"\nTOKEN_URL = f\"{BASE_URL}/api/auth/token/\"\nREFRESH_URL = f\"{BASE_URL}/api/auth/token/refresh/\"\nTIMEOUT = 30\n\ndef test_refresh_access_token():\n    # Use a valid test user to login and get a refresh token\n    login_payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        login_response = requests.post(TOKEN_URL, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        tokens = login_response.json()\n        assert \"refresh\" in tokens, \"Refresh token not found in login response\"\n        refresh_token = tokens[\"refresh\"]\n\n        refresh_payload = {\n            \"refresh\": refresh_token\n        }\n\n        refresh_response = requests.post(REFRESH_URL, json=refresh_payload, headers=headers, timeout=TIMEOUT)\n        assert refresh_response.status_code == 200, f\"Refresh token request failed with status code {refresh_response.status_code}\"\n        refresh_data = refresh_response.json()\n        assert \"access\" in refresh_data, \"Access token not returned in refresh response\"\n        new_access_token = refresh_data[\"access\"]\n        assert isinstance(new_access_token, str) and len(new_access_token) > 0, \"Invalid access token returned\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_refresh_access_token()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 20, in test_refresh_access_token\nAssertionError: Login failed with status code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.610Z",
    "modified": "2025-11-17T16:25:19.118Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "b0bae8af-eaeb-407c-b84e-084903a4fd7f",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC003-login with biometric authentication",
    "description": "Test the /api/auth/biometric-auth/login/ endpoint to verify that users can login successfully using biometric authentication methods.",
    "code": "import requests\n\ndef test_login_with_biometric_authentication():\n    base_url = \"http://localhost:3020\"\n    url = f\"{base_url}/api/auth/biometric-auth/login/\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Updated payload for biometric auth\n    payload = {\n        \"biometric_token\": \"example-token\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not in JSON format\"\n    \n    # Based on JWT-based auth mentioned in PRD, expect access and refresh tokens\n    assert \"access\" in data, \"Response JSON does not contain 'access' token\"\n    assert \"refresh\" in data, \"Response JSON does not contain 'refresh' token\"\n\ntest_login_with_biometric_authentication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 29, in <module>\n  File \"<string>\", line 19, in test_login_with_biometric_authentication\nAssertionError: Expected status code 200 but got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.616Z",
    "modified": "2025-11-17T16:25:19.125Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "c260721b-d428-4cc1-80b0-956f6195274a",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC004-send otp for two factor authentication",
    "description": "Test the /api/auth/otp/send/ endpoint to verify that an OTP is sent correctly for two-factor authentication purposes.",
    "code": "import requests\n\ndef test_send_otp_for_two_factor_authentication():\n    base_url = \"http://localhost:3020\"\n    url = f\"{base_url}/api/auth/otp/send/\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": \"testuser@example.com\"\n    }\n    timeout = 30\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=timeout)\n        assert response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n        json_response = response.json()\n        assert \"detail\" in json_response or \"message\" in json_response or json_response.get(\"success\", False) or json_response.get(\"otp_sent\", False), \\\n            \"Response does not indicate OTP send success\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_send_otp_for_two_factor_authentication()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 15, in test_send_otp_for_two_factor_authentication\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 23, in <module>\n  File \"<string>\", line 21, in test_send_otp_for_two_factor_authentication\nAssertionError: Request failed: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.621Z",
    "modified": "2025-11-17T16:25:12.409Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "0af8d532-eb5f-43d0-8d20-05f7c17eebbf",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC005-verify otp",
    "description": "Test the /api/auth/otp/verify/ endpoint to verify that the OTP provided by the user is validated correctly for two-factor authentication.",
    "code": "import requests\n\ndef test_verify_otp():\n    base_url = \"http://localhost:3020\"\n    otp_send_url = f\"{base_url}/api/auth/otp/send/\"\n    otp_verify_url = f\"{base_url}/api/auth/otp/verify/\"\n    headers = {\"Content-Type\": \"application/json\"}\n    timeout = 30\n\n    # For test purposes, use a test email\n    test_email = \"testuser@example.com\"\n\n    try:\n        # Step 1: Send OTP\n        send_payload = {\"email\": test_email}\n        send_response = requests.post(otp_send_url, json=send_payload, headers=headers, timeout=timeout)\n        assert send_response.status_code == 200, f\"Failed to send OTP, status code: {send_response.status_code}\"\n        send_data = send_response.json()\n        assert \"otp\" in send_data or \"detail\" in send_data, \"OTP not sent successfully.\"\n\n        # Assuming OTP is returned in response for test environment or fetched via mock\n        # If OTP not returned, test cannot proceed further automatically.\n        otp = send_data.get(\"otp\")\n        if not otp:\n            raise ValueError(\"No OTP received in send response; manual input needed or test environment must provide OTP.\")\n\n        # Step 2: Verify OTP\n        verify_payload = {\n            \"email\": test_email,\n            \"otp\": otp\n        }\n        verify_response = requests.post(otp_verify_url, json=verify_payload, headers=headers, timeout=timeout)\n        assert verify_response.status_code == 200, f\"OTP verification failed with status code {verify_response.status_code}\"\n        verify_data = verify_response.json()\n        # Assumption: Successful verification returns JSON with success message or token\n        assert verify_data.get(\"detail\") == \"OTP verified successfully\" or \"token\" in verify_data, \"OTP verification response invalid\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n    except AssertionError as e:\n        assert False, f\"Assertion failed: {e}\"\n\n\ntest_verify_otp()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 17, in test_verify_otp\nAssertionError: Failed to send OTP, status code: 401\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 44, in <module>\n  File \"<string>\", line 41, in test_verify_otp\nAssertionError: Assertion failed: Failed to send OTP, status code: 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.626Z",
    "modified": "2025-11-17T16:25:20.506Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "6e7569ab-0fcc-46f2-93a2-ca22965387fe",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC006-list all restaurants with filters",
    "description": "Test the /api/restaurants/restaurants/ endpoint to verify that it returns a list of restaurants filtered correctly by search keyword, cuisine type, and rating.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3020\"\nTIMEOUT = 30\n\n# Placeholder token, adjust as appropriate\nAUTH_TOKEN = \"Bearer your_valid_jwt_token_here\"\n\ndef test_list_all_restaurants_with_filters():\n    url = f\"{BASE_URL}/api/restaurants/restaurants/\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Authorization\": AUTH_TOKEN\n    }\n\n    # Define filter parameters to test\n    params_list = [\n        {\"search\": \"pizza\", \"cuisine\": None, \"rating\": None},\n        {\"search\": None, \"cuisine\": \"Italian\", \"rating\": None},\n        {\"search\": None, \"cuisine\": None, \"rating\": 4},\n        {\"search\": \"sushi\", \"cuisine\": \"Japanese\", \"rating\": 5},\n        {\"search\": \"\", \"cuisine\": \"\", \"rating\": None}  # empty filters, should return all\n    ]\n\n    for params in params_list:\n        # Clean params to exclude None values\n        query_params = {k: v for k, v in params.items() if v is not None and v != \"\"}\n        try:\n            response = requests.get(url, headers=headers, params=query_params, timeout=TIMEOUT)\n            assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n            data = response.json()\n            assert isinstance(data, list), \"Response should be a list of restaurants\"\n\n            # Verify filtering if filters applied\n            for restaurant in data:\n                if \"search\" in query_params:\n                    search_lower = query_params[\"search\"].lower()\n                    name = restaurant.get(\"name\", \"\").lower()\n                    description = restaurant.get(\"description\", \"\").lower() if restaurant.get(\"description\") else \"\"\n                    assert search_lower in name or search_lower in description, \\\n                        f\"Restaurant does not match search filter: {restaurant}\"\n                if \"cuisine\" in query_params:\n                    cuisine_filter = query_params[\"cuisine\"].lower()\n                    cuisines = [c.lower() for c in restaurant.get(\"cuisines\", [])] if isinstance(restaurant.get(\"cuisines\"), list) else []\n                    assert cuisine_filter in cuisines, f\"Restaurant does not match cuisine filter: {restaurant}\"\n                if \"rating\" in query_params:\n                    rating_filter = float(query_params[\"rating\"])\n                    rating = float(restaurant.get(\"rating\", 0))\n                    assert rating >= rating_filter, f\"Restaurant rating lower than filter: {restaurant}\"\n\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\ntest_list_all_restaurants_with_filters()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 54, in <module>\n  File \"<string>\", line 30, in test_list_all_restaurants_with_filters\nAssertionError: Expected status 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.631Z",
    "modified": "2025-11-17T16:25:22.578Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "89b92a27-f797-45bb-b653-1e2b791afe4a",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC007-get restaurant details",
    "description": "Test the /api/restaurants/restaurants/{id}/ endpoint to verify that it returns detailed information for a specific restaurant identified by id.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3020\"\nTIMEOUT = 30\n\n# Assuming no authentication info was provided, so this example does not authenticate.\n# In real scenario, add JWT token in headers if required, e.g.:\n# HEADERS = {\"Authorization\": f\"Bearer {token}\"}\n\ndef test_get_restaurant_details():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    # Step 1: Get list of restaurants to obtain a valid restaurant id\n    try:\n        list_resp = requests.get(f\"{BASE_URL}/api/restaurants/restaurants/\", headers=headers, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Failed to list restaurants, status code: {list_resp.status_code}\"\n        restaurants = list_resp.json()\n        assert isinstance(restaurants, list), \"Restaurants response is not a list\"\n        assert len(restaurants) > 0, \"No restaurants found to test details endpoint\"\n        restaurant_id = None\n        # The endpoint in PRD /api/restaurants/restaurants/ returns list. \n        # The format of each restaurant in list is unknown, we assume each has 'id' key.\n        for r in restaurants:\n            if isinstance(r, dict) and 'id' in r:\n                restaurant_id = r['id']\n                break\n        assert restaurant_id is not None, \"No valid restaurant id found in list response\"\n\n        # Step 2: Query the details endpoint for that restaurant id\n        details_resp = requests.get(f\"{BASE_URL}/api/restaurants/restaurants/{restaurant_id}/\", headers=headers, timeout=TIMEOUT)\n        assert details_resp.status_code == 200, f\"Failed to get restaurant details, status code: {details_resp.status_code}\"\n        details = details_resp.json()\n        assert isinstance(details, dict), \"Restaurant details response is not a dictionary\"\n        assert details.get(\"id\") == restaurant_id, \"Returned restaurant id does not match requested id\"\n        # Additional possible validations:\n        # eg. check for expected keys in details like name, address, cuisine, rating etc if known\n        expected_keys = [\"id\", \"name\", \"address\", \"cuisine\", \"rating\"]\n        missing_keys = [key for key in expected_keys if key not in details]\n        assert not missing_keys, f\"Missing expected keys in restaurant details: {missing_keys}\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_get_restaurant_details()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 17, in test_get_restaurant_details\nAssertionError: Failed to list restaurants, status code: 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.637Z",
    "modified": "2025-11-17T16:25:27.321Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "0d982805-04bb-4101-a292-0ee387de1605",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC008-create new order",
    "description": "Test the /api/orders/orders/ POST endpoint to verify that a user can create a new order by providing valid restaurant id, items, and delivery address id.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3020\"\nTIMEOUT = 30\n\n# Dummy credentials for authentication - replace with valid test user credentials\nAUTH_EMAIL = \"testuser@example.com\"\nAUTH_PASSWORD = \"TestPassword123!\"\n\ndef test_create_new_order():\n    try:\n        # Step 1: Authenticate user to obtain JWT access token\n        auth_url = f\"{BASE_URL}/api/auth/token/\"\n        auth_payload = {\n            \"email\": AUTH_EMAIL,\n            \"password\": AUTH_PASSWORD\n        }\n        auth_headers = {\n            \"Content-Type\": \"application/json\"\n        }\n        auth_response = requests.post(auth_url, json=auth_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert auth_response.status_code == 200, f\"Authentication failed: {auth_response.text}\"\n        tokens = auth_response.json()\n        access_token = tokens.get(\"access\")\n        assert access_token, \"Access token not found in authentication response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Step 2: Get list of restaurants to obtain a valid restaurant_id\n        restaurants_url = f\"{BASE_URL}/api/restaurants/restaurants/\"\n        restaurants_response = requests.get(restaurants_url, headers=headers, timeout=TIMEOUT)\n        assert restaurants_response.status_code == 200, f\"Failed to list restaurants: {restaurants_response.text}\"\n        restaurants = restaurants_response.json()\n        assert isinstance(restaurants, list) and len(restaurants) > 0, \"No restaurants found for order creation\"\n        restaurant_id = restaurants[0].get(\"id\")\n        assert restaurant_id, \"Restaurant ID missing in restaurants list\"\n\n        # Step 3: Get menu items for the chosen restaurant to prepare order items\n        menu_url = f\"{BASE_URL}/api/restaurants/restaurants/{restaurant_id}/menu/\"\n        menu_response = requests.get(menu_url, headers=headers, timeout=TIMEOUT)\n        assert menu_response.status_code == 200, f\"Failed to get menu: {menu_response.text}\"\n        menu_items = menu_response.json()\n        assert isinstance(menu_items, list) and len(menu_items) > 0, \"No menu items found for the selected restaurant\"\n\n        # Prepare items list with at least one item and quantity (assuming quantity 1)\n        item_id = menu_items[0].get(\"id\")\n        assert item_id, \"Menu item ID missing\"\n        items = [{\"item_id\": item_id, \"quantity\": 1}]\n\n        # Step 4: Get delivery addresses\n        profile_url = f\"{BASE_URL}/api/accounts/profile/\"\n        profile_response = requests.get(profile_url, headers=headers, timeout=TIMEOUT)\n        if profile_response.status_code != 200 or not profile_response.json().get(\"delivery_addresses\"):\n            orders_url = f\"{BASE_URL}/api/orders/orders/\"\n            orders_response = requests.get(orders_url, headers=headers, timeout=TIMEOUT)\n            assert orders_response.status_code == 200, f\"Failed to list orders: {orders_response.text}\"\n            orders = orders_response.json()\n            delivery_address_id = None\n            for order in orders:\n                if order.get(\"delivery_address_id\"):\n                    delivery_address_id = order[\"delivery_address_id\"]\n                    break\n            assert delivery_address_id, \"No delivery address id found from previous orders\"\n        else:\n            delivery_addresses = profile_response.json().get(\"delivery_addresses\")\n            assert isinstance(delivery_addresses, list) and len(delivery_addresses) > 0, \"No delivery addresses found\"\n            delivery_address_id = delivery_addresses[0].get(\"id\")\n            assert delivery_address_id, \"Delivery address ID missing\"\n\n        # Step 5: Create new order\n        create_order_url = f\"{BASE_URL}/api/orders/orders/\"\n        order_payload = {\n            \"restaurant_id\": restaurant_id,\n            \"items\": items,\n            \"delivery_address_id\": delivery_address_id\n        }\n        order_response = requests.post(create_order_url, json=order_payload, headers=headers, timeout=TIMEOUT)\n        assert order_response.status_code == 201, f\"Order creation failed: {order_response.status_code} - {order_response.text}\"\n        order_data = order_response.json()\n        assert order_data.get(\"id\"), \"Order ID missing in response\"\n        assert order_data.get(\"restaurant_id\") == restaurant_id, \"Restaurant ID mismatch in order response\"\n        assert order_data.get(\"delivery_address_id\") == delivery_address_id, \"Delivery address ID mismatch in order response\"\n        assert isinstance(order_data.get(\"items\"), list) and len(order_data[\"items\"]) > 0, \"Order items missing in response\"\n\n    except (requests.RequestException, AssertionError) as e:\n        assert False, f\"Test failed due to error: {str(e)}\"\n\n\ntest_create_new_order()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 22, in test_create_new_order\nAssertionError: Authentication failed: \n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 92, in <module>\n  File \"<string>\", line 89, in test_create_new_order\nAssertionError: Test failed due to error: Authentication failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.643Z",
    "modified": "2025-11-17T16:25:35.870Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "562752cf-155f-474e-9b26-2a9961fa09e8",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC009-process payment",
    "description": "Test the /api/payments/payments/ endpoint to verify that payments can be processed successfully using supported payment methods including credit card, UPI, wallet, and cash on delivery.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3020\"\nPAYMENTS_ENDPOINT = \"/api/payments/payments/\"\nTIMEOUT = 30\n\n# Example auth token (replace with a real valid token for actual testing)\nAUTH_TOKEN = \"your_valid_jwt_token_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_process_payment():\n    payment_methods_payloads = [\n        {\n            \"payment_method\": \"credit_card\",\n            \"amount\": 100.00,\n            \"currency\": \"USD\",\n            \"details\": {\n                \"card_number\": \"4111111111111111\",\n                \"expiry_month\": \"12\",\n                \"expiry_year\": \"2030\",\n                \"cvv\": \"123\",\n                \"cardholder_name\": \"John Doe\"\n            }\n        },\n        {\n            \"payment_method\": \"upi\",\n            \"amount\": 50.00,\n            \"currency\": \"INR\",\n            \"details\": {\n                \"upi_id\": \"john.doe@upi\"\n            }\n        },\n        {\n            \"payment_method\": \"wallet\",\n            \"amount\": 25.00,\n            \"currency\": \"USD\",\n            \"details\": {\n                \"wallet_id\": \"wallet_user_123\"\n            }\n        },\n        {\n            \"payment_method\": \"cash_on_delivery\",\n            \"amount\": 75.00,\n            \"currency\": \"USD\",\n            \"details\": {}\n        }\n    ]\n\n    for payload in payment_methods_payloads:\n        response = None\n        try:\n            response = requests.post(\n                BASE_URL + PAYMENTS_ENDPOINT,\n                json=payload,\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert response.status_code == 200 or response.status_code == 201, (\n                f\"Failed for payment method {payload['payment_method']}: Unexpected status code {response.status_code}\"\n            )\n            resp_json = response.json()\n            # Basic checks for expected keys in response\n            assert \"payment_id\" in resp_json, f\"'payment_id' missing in response for {payload['payment_method']}\"\n            assert resp_json.get(\"status\") in (\"success\", \"pending\", \"completed\"), (\n                f\"Unexpected payment status for {payload['payment_method']} payment: {resp_json.get('status')}\"\n            )\n        except requests.exceptions.RequestException as e:\n            assert False, f\"Request failed for payment method {payload['payment_method']}: {str(e)}\"\n        finally:\n            if response is not None:\n                response.close()\n\ntest_process_payment()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 78, in <module>\n  File \"<string>\", line 63, in test_process_payment\nAssertionError: Failed for payment method credit_card: Unexpected status code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.648Z",
    "modified": "2025-11-17T16:25:35.210Z"
  },
  {
    "projectId": "8702ed4e-6d81-4e6e-a84f-5c2e447e6db7",
    "testId": "7b6ce58d-e341-4279-82ef-639580129eef",
    "userId": "443844d8-3041-7007-f840-db74c6bab9a0",
    "title": "TC010-list user notifications",
    "description": "Test the /api/notifications/ GET endpoint to verify that it returns the list of notifications for the authenticated user correctly.",
    "code": "import requests\n\ndef test_list_user_notifications():\n    base_url = \"http://localhost:3020\"\n    login_url = f\"{base_url}/api/auth/token/\"\n    notifications_url = f\"{base_url}/api/notifications/\"\n    email = \"testuser@example.com\"\n    password = \"TestPassword123!\"\n    timeout = 30\n\n    # Step 1: Authenticate user to get JWT tokens\n    login_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=timeout)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        tokens = login_response.json()\n        assert \"access\" in tokens, \"Access token not found in login response\"\n        access_token = tokens[\"access\"]\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    # Step 2: Use access token to get user notifications\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    try:\n        notif_response = requests.get(notifications_url, headers=headers, timeout=timeout)\n        assert notif_response.status_code == 200, f\"Notification request failed with status code {notif_response.status_code}\"\n        notifications = notif_response.json()\n        assert isinstance(notifications, list), \"Notifications response is not a list\"\n        # Additional validation can be done here based on notifications structure if known\n    except requests.RequestException as e:\n        assert False, f\"Notification request failed: {e}\"\n\ntest_list_user_notifications()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 38, in <module>\n  File \"<string>\", line 18, in test_list_user_notifications\nAssertionError: Login failed with status code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T16:21:31.653Z",
    "modified": "2025-11-17T16:25:35.400Z"
  }
]
